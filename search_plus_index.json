{"./":{"url":"./","title":"Introduction","keywords":"","body":"Introduction "},"part-ii/ji-yu-docker-ji-jenkins-de-ci-cd-de-shi-xian.html":{"url":"part-ii/ji-yu-docker-ji-jenkins-de-ci-cd-de-shi-xian.html","title":"基于Docker及Jenkins的CI/CD的实现","keywords":"","body":"传统交付方案 传统我们的项目开发模式是产品调研提出需求，开发团队研究决定开发方案选型。然后开始一个周期的开发，模块开发完成之后开始模块间的联调。联调结束之后打包交付给测试团队。测试团队进行系统测试或自动化测试，然后提交bug，开发团队修复bug，周而复始。 传统的模式中，存在着较多的不确定因素。例如，开发环境、编译环境、测试环境、生产环境等不确定因素。人为介入打包中的不确定因素，缺乏单元测试和自动化测试的整合。从而导致的结果是，开发-测试-修复的周期较长，而且很多小的问题完全可以由单元测试进行覆盖。 持续交付 随着微服务架构与容器虚拟化技术的发展，越来越多的公司开始使用持续集成的系统来解决频繁发布带来的质量问题，使用持续交付的工具来实现代码在不同环境上的自动部署。 持续交付要求团队可以随时的发布一个新的准确版本，而且要求在编译发布的过程中进行自动化测试，通过自动化测试可以及时的发现并定位存在的bug，修复bug之后再进行快速的发布到测试环境，测试团队直接进行测试。 与传统模式的区别在于持续交付可以提前发现bug的存在和快速修复而不必等到测试人员的介入之后才发现。持续交付分解出来就是“持续”和“交付”。 持续：持续要求任何时候、任何情况都能进行准确的发布，做到准确的发布需要注意以下几个关键点： 持续应该是一个周期性的，可以是每天的某个时间点，也可以是某次代码的提交，或者某次人为触发。所以人工进行构建是不可能的，需要自动化的构建，自动化要求构建的任何一个流程都必须以脚本的形式运行，代码检出、代码构建、各模块代码单元测试、集成测试、UI自动化测试等 发布的程序版本不允许是各个模块在开发环境编译出一个版本作为交付，而要求在一个纯净的编译环境中进行构建。 构建的过程应该要求最大可能的固化，例如操作系统的版本，构建环境的版本，相关的依赖等。 避免从网络获取相关的文件，这点以nodejs为开发或编译的项目尤其重要，安装node的依赖包总是一个漫长的过程，就算有国内的源，一般的项目也需要一两分钟的node依赖包，这不符合快速构建。 交付：在持续集成完成之后，接着就是软件的交付工作，常见的交付方式一般有： 源代码交付: 源代码交付需要将源代码以 tar 包等方式 download 到服务器，然后在服务器上借助程序的构建脚本去构建可执行程序，显然这种方式会经常因服务器环境差异，构建环境初始化失败等问题导致无法构建可执行程序。严重依赖于构建脚本的完备程度。 Linux 标准包交付: 将项目的依赖通过 Linux deb 或者 rpm 来管理，由于这种方式更符合 Linux 规范，间接的提高了项目在服务器上部署的成功率，但是有些时候仍然需要解决包冲突问题。 虚拟镜像交付: 虚拟镜像交付指的是我们将项目在虚拟机里测试成功后直接将该虚拟镜像部署到服务器上。显然，这种方式部署成功率接近100%而且隔离性好。但是随之而来的问题就是虚拟镜像本身对服务器资源的消耗。 docker image 交付： docker image 交付是虚拟镜像交付的进一步演进，在保证系统隔离的同时，docker image 对服务器的资源消耗更低。当然，docker 的隔离机制是进程级别的，可能不适合一些强隔离场景。我们团队目前正在使用这种方式进行交付。 下图展示了一个典型的CI/CD的工具链，Jenkins作为业内优秀的的CI/CD工具，担任整套了工具链的核心组织工作。 CI、CD的实践方案 在持续集成方面选择Jenkins。Jenkins是一款开源软件，拥有众多优秀的插件，依靠这些插件，我们可以完成一些周期、繁琐、复杂的任务。虽然Jenkins解决了我们繁琐复杂周期性的操作，但是没有解决我们在多种环境下编译构建的需求。而这个场景正是Docker的强项。 通过Jenkins的pipeline我们可以实现代码检出、单元测试、编译、构建、发布、测试等流程的自动化，而最终通过Jenkins的Docker插件将产出物构建成镜像，方便部署到Docker环境。 在持续交付中选择了Docker image的交付方式，使用Docker有以下优点。 Docker强大的环境隔离性可以将环境和程序打包在一起，测试、运维人员无需知道我们的程序是如何配置的，只需要一条Docker 的命令就可以将我们的程序运行起来，这也更加容易实现持续部署。 减少编译环境的污染，因为Docker天然的隔离性，也避免了传统编译环境难以配置多套编译环境的问题。在基于Docker的持续发布中，我们可以在同一台宿主机上同时编译不同版本的Java项目，不同版本的Python项目，而无需任何配置，镜像也只是从docker hub中获取。 持续集成构建的docker 镜像经历了单元测试，自动化测试，但还没有接受过测试团队的严格测试。Jenkins是一个强大的持续集成工具，然而持续部署并不是Jenkins的强项，但是Jenkins拥有很多强大的插件。而且我们持续集成产出的是docker镜像，所以持续部署，我们只需要将镜像运行起来，或者利用第三方的容器管理平台提供的API进行部署。 本地部署应用到Docker：本地部署到Docker容器可以使用Jenkins的docker插件 部署到远程主机的Docker、Appsoar：Docker和Appsoar都支持开启API调用。通过现有的API我们可以运行我们生成镜像版本。从而达到持续的部署最新版本。 部署到kubernetes：kubernetes除了可以通过API调用还可以在jenkins中配置kubectl的方式创建或更新deployments。 基于Dokcer、Jenkins的CI/CD的实现 下图展示了一个简易实现的CI/CD流程，基于docker和Jenkins： 为了实现上图的CI/CD流程，需要搭建Jenkins master服务器、私有的Docker registry、Git服务器。 对于开发人员而言，相比传统发布，需要新增工作内容是在代码目录中新增Dockerfile和Jenkinsfile两个文件。Dockerfile用于应用发布时构建应用容器镜像，Jenkinsfile用于Jenkins pipeline。 "},"part-ii/jenkins-master-node.html":{"url":"part-ii/jenkins-master-node.html","title":"Jenkins master node","keywords":"","body":"Jenkins master节点部署 获取Jenkins镜像 从官方DockerHub上拉取Jenkins镜像： root@ubuntu:/# docker pull qinyu/jenkins Using default tag: latest latest: Pulling from qinyu/jenkins cfc728c1c558: Pull complete 5b12b87f0a0e: Pull complete b7d6497a92f9: Downloading [========> ] 12.24MB/70MB 7c6644ff6c63: Downloading [================> ] 8.09MB/25.25MB 48973060083e: Download complete af01d2ab7c3e: Download complete aebc5599e186: Download complete e38dd7110c4f: Download complete 141c7a122953: Downloading [=> ] 2.135MB/72.74M 镜像使用方法 设置管理员帐号密码（下面例子用户名和密码都是admin，可以自己调整） root@ubuntu:/# echo \"admin\" | docker secret create jenkins-user - vtukek9s2qqhaaief1gd9ybc2 root@ubuntu:/# echo \"admin\" | docker secret create jenkins-pass - mhufs3gua7yt0th8fgm5xlqli 创建jenkins.yml文件： version: '3.1' services: main: image: qinyu/jenkins:latest ports: - 8088:8080 - 50008:50000 volumes: - /home/jrr/jenkins-mnt:/var/jenkins_home - /var/run/docker.sock:/var/run/docker.sock secrets: - jenkins-user - jenkins-pass secrets: jenkins-user: external: true jenkins-pass: external: true 使用docker stack部署服务（配置见jenkins.yml，如有必要可以修改 volume /var/jenkins_home的挂载路径） root@ubuntu:~# docker stack deploy -c jenkins.yml jenkins_ci_cd Creating network jenkins_ci_cd_default Creating service jenkins_ci_cd_main root@ubuntu:~# docker stack services jenkins_ci_cd ID NAME MODE REPLICAS IMAGE PORTS rycy7rhssomk jenkins_ci_cd_main replicated 1/1 qinyu/jenkins:latest *:8088->8080/tcp,*:50008->50000/tcp root@ubuntu:~# docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 948ba8ce9806 qinyu/jenkins:latest \"/bin/tini -- /usr...\" 3 minutes ago Up 3 minutes 8080/tcp, 50000/tcp jenkins_ci_cd_main.1.r28yjkykxi3pstvzdqomk67e9 验证Jenkins master节点启动，在浏览器访问 http://192.168.139.132:8088/： 其他补充 Docker在1.12版的引擎中内置编排能力，也就是 Swarm Mode，在容器之上引入了服务(service)的概念，也实验性的推出了应用栈(stack)来支持多服务应用的部署管理。但是 Docker 1.12 版本，服务的开发和操作缺乏类似Docker Compose工具的支持，而且由于Docker Compose v1/v2是面向容器编排设计，和Swarm Mode中的概念上有很多不同。只可以用 docker-compose bundle 命令将已有 docker-compose.yml 转换为 Distributed Application Bundle 才能在Swarm mode中部署，非常不便，而且更为严重的是很多功能不支持，导致很多现有编排模板无法直接使用。 在2017年1月发布的 Docker 1.13版本中，Swarm mode迅速成熟，相应的工具支持也进一步完善。 Docker Composev3 规范，已经全面支持 Swarm mode 概念。而且从 1.13 开始，Docker 命令行工具支持直接使用 v3 版本的 docker-compose.yml 文件来进行应用栈(stack)部署管理，这大大简化了容器编排使用的复杂性。 Docker Compose v1/v2 Docker 1.13 启动服务 docker-compose up -d docker stack deploy --compose-file=docker-compose.yml 伸缩服务 docker-compose scale xxx=n docker service scale xxx=n 停止服务 docker-compose down docker stack rm 跨宿主机 否 是 "},"part-ii/jenkins-pipeline.html":{"url":"part-ii/jenkins-pipeline.html","title":"Jenkins Pipeline","keywords":"","body":"什么是Pipeline 16年4月20日，历经Alpha(2/29)，Beta(3/24)，RC(4/7)3个版本的迭代，Jenkins 2.0 正式发布。这也是Jenkins面世11年以来的首次大版本升级。 Pipeline as Code是Jenkins 2.0的精髓所在，是Jenkins实现CI(Continuous Integration)到CD(Continuous Delivery)转变的关键推手。所谓Pipeline，就是一套运行于Jenkins上的工作流框架，将原本独立运行于单个或者多个节点的任务连接起来，实现单个任务难以完成的复杂发布流程。Pipeline的实现方式是一套Groovy DSL，任何发布流程都可以表述为一段Groovy脚本，并且Jenkins支持从代码库直接读取脚本（Jenkinsfile），从而实现了Pipeline as Code的理念。 Pipeline的几个基本概念： Stage: 阶段，一个Pipeline可以划分为若干个Stage，每个Stage代表一组操作。注意，Stage是一个逻辑分组的概念，可以跨多个Node。 Node: 节点，一个Node就是一个Jenkins节点，或者是Master，或者是Agent，是执行Step的具体运行期环境。 Step: 步骤，Step是最基本的操作单元，小到创建一个目录，大到构建一个Docker镜像，由各类Jenkins Plugin提供 创建Pipeline Pipeline脚本是用Groovy写的，可以通过以下任一方式创建基本Pipeline： pipeline script：直接在Web UI的script输入框里面输入pipeline script语句即可，参考说明可以点击输入框下边的Pipeline Syntax，里面有很多示例操作说明，非常好用。 pipeline script from SCM：需要配置SCM代码存储Git地址或SVN地址，指定script文件Jenkinsfile所在路径，每次构建job会自动去指定的目录执行script文件 基于前面安装的Jenkins master，进入jenkins主页：http://192.168.139.132:8088/，点击左边菜单的新建选项： 选择\"Pipeline\"类型并输入项目名： 进入项目的配置页面，首先配置项目的自动触发： 在Web UI中定义Pipeline 在Pipeline配置页面的文本区域内，输入Pipeline script： 在SCM中定义pipeline 复杂的Pipeline难以在Pipeline配置页面的文本区域内进行写入和维护。为了解决这一问题，jenkins Pipeline支持在文本编辑器中编写脚本文件jenkinsFile，Jenkins可以通过从SCM选项的控件中加载Pipeline脚本。 选择SCM选项中的Pipeline脚本后，不要在Jenkins UI中输入任何Groovy代码; 只需指定要检索的Pipeline脚本的路径。更新指定的存储库时，只要Pipeline配置了SCM轮询触发器，就会触发一个新构建。 Pipeline语法 Pipeline最基本的部分是“step”。基本上，step告诉Jenkins 要做什么，并且作为Declarative Pipeline和Scripted Pipeline语法的基本构建块。 Pipeline支持两种语法：Declarative Pipeline（在Pipeline 2.5中引入，结构化方式）和Scripted Pipeline，两者都支持建立连续输送的Pipeline。 Declarative Pipeline Declarative Pipeline是Jenkins Pipeline 的一个相对较新的补充， 它在Pipeline子系统之上提出了一种更为简化和有意义的语法。 所有有效的Declarative Pipeline必须包含在一个pipeline块内，例如： pipeline { /* insert Declarative Pipeline here */ } Declarative Pipeline中的基本语句和表达式遵循与Groovy语法相同的规则 ，但有以下例外： Pipeline的顶层必须是块，具体来说是：pipeline { } 没有分号作为语句分隔符。每个声明必须在自己的一行 块只能包含Sections, Directives, Steps或赋值语句。 属性引用语句被视为无参方法调用。所以例如，输入被视为input（） 例子： Jenkinsfile (Declarative Pipeline) pipeline { agent any stages { stage('Build') { steps { sh 'make' } } stage('Test'){ steps { sh 'make check' junit 'reports/**/*.xml' } } stage('Deploy') { steps { sh 'make publish' } } } } Scripted Pipeline Scripted pipeline是基于groovy的一种DSL语言，与Declarative pipeline相比为jenkins用户提供了更巨大的灵活性和可扩展性。 例子： Jenkinsfile (Scripted Pipeline) node { stage('Build') { sh 'make' } stage('Test') { sh 'make check' junit 'reports/**/*.xml' } stage('Deploy') { sh 'make publish' } } Declarative pipeline和Scripted pipeline的比较 共同点： 两者都是pipeline代码的持久实现，都能够使用pipeline内置的插件或者插件提供的steps，两者都可以利用共享库扩展。 区别： 两者不同之处在于语法和灵活性。Declarative pipeline对用户来说，语法更严格，有固定的组织结构，更容易生成代码段，使其成为用户更理想的选择。但是Scripted pipeline更加灵活，因为Groovy本身只能对结构和语法进行限制，对于更复杂的pipeline来说，用户可以根据自己的业务进行灵活的实现和扩展。 Jenkinsfile样例 //push to private registry node { stage('Check out source code') { // for display purposes // Get some code from a GitHub repository git 'https://github.com/raiseking/docker-hello-world.git' } stage('Build and push docker image'){ docker.withRegistry('http://192.168.139.129:5000/') { docker.image('maven:3.5-alpine').inside('-v $HOME/.m2:/root/.m2') { // Run the maven build sh \"mvn clean package\" } def customImage = docker.build(\"192.168.139.129:5000/docker-cicd:${env.BUILD_ID}\") customImage.push() } } stage('Deploy with docker image') { echo \"Deploy artifact image to docker env.\" docker.withRegistry('http://192.168.139.129:5000/') { sh \"docker pull 192.168.139.129:5000/docker-cicd:${env.BUILD_ID}\" sh \"docker run -d -p 8888:8080 192.168.139.129:5000/docker-cicd:${env.BUILD_ID}\" } } } 参考 https://jenkins.io/doc/book/pipeline/getting-started/ https://jenkins.io/doc/book/pipeline/syntax/ "},"part-ii/private-docker-registry.html":{"url":"part-ii/private-docker-registry.html","title":"Private docker registry","keywords":"","body":"Docker提供了开放的中央仓库dockerhub，同时也允许我们使用registry搭建本地私有仓库。搭建私有仓库有如下的优点： 节省网络带宽，提升Docker部署速度，不用每个镜像从DockerHub上去下载，只需从私有仓库下载就可； 私有镜像，包含公司敏感信息，不方便公开对外，只在公司内部使用。 搭建私有仓库 下载 registry 镜像 docker pull registry 启动容器 docker run -d --name registry-jrr -p 5000:5000 --restart=always -v /opt/data/registry:/tmp/registry registry 简单解释： -p：将容器的5000端口映射到宿主机的5000端口 --restart：docker服务重启后总是重启此容器 --name：容器的名称 -v：将容器内的/tmp/registry映射到宿主机的/opt/data/registry目录 验证私有仓库功能 sudo docker pull busybox //从DockerHub拉取测试镜像 sudo docker tag busybox registry_ip:5000/busybox //给测试镜像打上私有仓库标签 sudo docker push registry_ip:5000/busybox //上传镜像至私有仓库 sudo docker pull registry_ip:5000/busybox //从私有仓库拉取镜像 可能出现的push错误 $ docker push 192.168.139.129:5000/busybox The push refers to a repository [192.168.139.129:5000/busybox] Get https://192.168.139.129:5000/v2: http: server gave HTTP response to HTTPS client 这是因为Docker在1.3.x之后默认docker registry使用的是https，为了解决这个问题，需要修改/etc/docker/daemon.json文件，在文件中添加： \"{ \"insecure-registries\":[\"192.168.139.129:5000\"] }\" 然后重启docker $ systemctl restart docker 查看私有仓库镜像 root@ubuntu:/home/jrr# curl -XGET http://192.168.139.129:5000/v2/_catalog {\"repositories\":[\"busybox\",\"docker-cicd\",\"maven\",\"openjdk\"]} root@ubuntu:/home/jrr# curl -XGET http://192.168.139.129:5000/v2/docker-cicd/tags/list {\"name\":\"docker-cicd\",\"tags\":[\"26\",\"22\",\"24\",\"21\",\"25\",\"23\",\"27\"]} root@ubuntu:/home/jrr# curl -XGET http://192.168.139.129:5000/v2/maven/tags/list {\"name\":\"maven\",\"tags\":[\"3.5-alpine\"]} 搭建WEB服务 私有仓库搭建好了，为了方便查看仓库里的镜像，利用第三方镜像搭建一个web服务。 下载镜像 $ docker pull hyper/docker-registry-web 启动容器 docker run -d -it -p 8080:8080 --restart=always --name registry-web-console --link registry-jrr -e REGISTRY_URL=http://192.168.139.129:5000/v2 -e REGISTRY_NAME=192.168.139.129:5000 hyper/docker-registry-web 简单解释： -it:以交互模式运行 --link：链接其它容器(registry-jrr)，在此容器中，使用registry-jrr等同于registry-jrr容器的局域网地址 -e：设置环境变量 wen端查看私有仓库镜像 访问: http://192.168.1.87:8080/： 其他 此处的私有仓库还没有把用户认证模块加进去，后面继续改进 "}}